<!DOCTYPE html>
<html>
    <head>
        <title>CPU Simulator - Page d'aide</title>
        <link rel="stylesheet" href="style.css">
        <link rel="shortcut icon" href="favicon.jpg" type="image/x-icon">
    </head>
    <body>
        <div>
            <header class="header">
                <img src="images/Logo.jpg" height="60 px" width="60 px">
                <p id="logo_text">CPU Simulator</p>
                <a id="table" href="#TableDeMatiere">Table de matiere</a>
            </header>
            <main>
                <section class="cards_container">
                    <div class="card">
                        <a href="#commencer" title="getting_started">
                            <img class="card_image" src="images/rocket.png" height="150px" width="150px">
                            <p class="card_title">Commencer</p>
                            <p class="card_description">Petite introduction <br> pour commencer <br> CPU Simulator</p>
                        </a>
                    </div>
                    <div class="card">
                        <a href="#accueil" title="Using_CS">
                            <img class="card_image" src="images/laptop.png" height="200px" width="200px">
                            <p class="card_title">Apprende avec <br> CPU Simulator</p>
                            <p class="card_description">Savoir comment bien utiliser CPU Simulator, pour avoir un meilleur apprentissage</p>
                        </a>
                    </div>
                </section>
                <section>
                    <div id="TableDeMatiere">
                        <p id="titre">Table de Matiere</p>
                        <ol>
                            <li class="big_titles">Commencer avec CPU Simulator</li>
                            <ol>
                                <li class="first_titles"><a href="#definition" class="second titles">Introduction à CPU Simulator</a></li>
                                <li class="first_titles"><a href="#guide">Un guide rapide d'utilisation</a></li>
                            </ol>
                            <br>
                            <li class="big_titles">Apprende avec CPU Simulator</li>
                            <ol>
                                <li class="first_titles"><a href="#accueil"> La page d'accueil</a></li>                            
                                <li class="first_titles">La simulation</li>
                                <ol>
                                    <li class="second titles"><a href="#lancerSimul">Comment lancer la simulation ?</a></li>
                                    <li class="second titles">Comment remplir le tableau des processus ?</li>
                                    <ol>
                                        <li class="third_title"><a href="#paps">PAPS : Premier Arrivé Premier Servi</a></li>
                                        <li class="third_title"><a href="#paps">PCA : Plus Court d'Abord</a></li>
                                        <li class="third_title"><a href="#paps">PLA : Plus Long d'Abord</a></li>
                                        <li class="third_title"><a href="#paps">PCTR : Plus Court Temps Restant d'abord</a></li>
                                        <li class="third_title"><a href="#psr">PSR : Algorithme avec priorité Sans Réquisition</a></li>
                                        <li class="third_title"><a href="#psr">PAR : Algorithme avec Priorité Avec Réquisition</a></li>
                                        <li class="third_title"><a href="#pard">PARD : Algorithme avec Priorité Avec Réquisition Dynamique</a></li>
                                        <li class="third_title"><a href="#rr">RR : Round Robin</a></li>
                                        <li class="third_title"><a href="#st">Slack-Time : Temps mort</a></li>
                                        <li class="third_title"><a href="#ml">ML : Files multi-niveaux</a></li>
                                        <li class="third_title"><a href="#ml">ML avec recyclage : Files multi-niveaux avec recyclage</a></li>
                                    </ol>
                                    <li class="second titles"><a href="#simuler">La page de simulation</a></li>
                                    <ol>
                                        <li class="third titles"><a  href="#processus">Le processus</a></li>
                                        <li class="third titles"><a  href="#simuler2">La page de simulation</a></li>
                                    </ol>
                                </ol>
                                <li class="first_titles"><a href="#comparaison">La comparaison</a></li>
                                <li class="first_titles"><a href="#explication">Fonctionnement des algorithmes </a></li>
                                <ul>
                                    <li class="second titles"><a href="#algo">Algorithme avec réquisition ou sans réquisition </a></li>
                                    <li class="second titles"><a href="#algos">Les  algorithmes d'ordonnancement</a></li>
                                </ul>
                                        <ol>
                                            <li class="third_title"><a href="#paps2">PAPS</a></li>
                                            <li class="third_title"><a href="#pca2">PCA</a></li>
                                            <li class="third_title"><a href="#pla2">PLA</a></li>
                                            <li class="third_title"><a href="#pctr2">PCTR</a></li>
                                            <li class="third_title"><a href="#psr2">PSR</a></li>
                                            <li class="third_title"><a href="#par2">PAR</a></li>
                                            <li class="third_title"><a href="#pard2">PARD</a></li>
                                            <li class="third_title"><a href="#rr2">RR</a></li>
                                            <li class="third_title"><a href="#st2">Slack-Time</a></li>
                                            <li class="third_title"><a href="#ml2">ML</a></li>
                                            <li class="third_title"><a href="#mlr2">MLR</a></li>
                                        </ol>
                            </ol>      
                        </ol>
                    </div>
                </section>
                <section class="text">
                    <div>
                        <ol>
                            <li class="big_titles" id="commencer">Commencer avec CPU Simulator</li>
                            <ol>
                                <li class="first_titles" id="definition">Introduction à CPU Simulator</li>
                                    <p>CPU Simulator est une application Desktop réalisée en 2021 dans le cadre du Projet 2CP permettant une simulation visuelle des processus afin d'aider les étudiants à comprendre le fonctionnement des différents algorithmes d'ordonnancement.</p>
                                <li class="first_titles" id="guide">Commencer avec CPU Simulator : Un guide rapide d'utilisation</li> 
                                Quand vous commencez CPU Simulator, vous trouvez une page d'accueil, Cliquez sur simuler et choisissez un parmi les algorithmes d'ordonnancement, puis remplissez le tableau des processus, et cliquez sur simuler pour commencer la simulation de votre algorithme choisi.  
                                <br> Cliquez sur comparer et choisissez les algorithmes que vous voulez comparer, remplissez le tableau des processus et cliquez sur comparer pour avoir les résultats de comparaison.
                            </ol>
                            <br>
                            <li class="big_titles">Apprende avec CPU Simulator</li>
                                <ol>                            
                                <li class="first_titles" id="accueil">La page d'accueil</li>
                                <img src="images/PageAccueil.png" height="80%" width="80%">
                                <p>Dans la page d'accueil, vous trouvez 2 boutons principaux, un pour faire la simulation visuelle des algorithmes 
                                    d'ordonnancement, <br><img src="images/simuler.png"><br> et l'autre pour faire la comparaison entre les algorithmes selon quelques critères.
                                    <br>
                                    En dessus, vous trouvez : <br>
                                    A propos : Une petite présentation de notre application, et des membres de l'équipe qui l'a réalisé.
                                    <br>
                                    <img src="images/Apropos.png">
                                    <br> Aide : La page d'aide de l'application. <br>
                                    <img src="images/Aide.png">
                                 
                                </p>
                                    <br>
                                <li class="first_titles">La simulation</li>
                                <ol>
                                    <li class="second titles" id="lancerSimul">Comment lancer la simulation ?</li>
                                    <p>Pour commencer la simulation, cliquez sur le bouton "Simuler" dans la page d'accueil, <br><img src="images/simuler.png"><br> Puis choisissez un algorithme 
                                        parmi les 11 algorithmes d'ordonnancement : 
                                        <img src="images/PageAlgos1.png" height="80%" width="80%"><br> cliquez sur le bouton "suivant" <br><img src="images/Next.png"><br>
                                        Pour passer aux algorithmes : <br><img src="images/PageAlgos2.png" width="80%" height="80%"> <br> Ensuite, remplissez le tableau des processus,et vous cliquez sur "simuler".</p>
                                    <p>
                                    <li class="second titles">Comment remplir le tableau des processus ?</li>
                                    <ol>
                                        <li class="third_title" id="paps">PAPS, PCA, PLA, PCTR</li>
                                        <p>Quand vous cliquez sur l'algorithme , la page de saisie s'ouvre, <img src="images/PageSaisie.png" height="80%" width="80%"><br> vous trouvez 4 boutons dans l'entête de la page : le bouton "Home"
                                            pour revenir à la page d'accueil, <br><img src="images/Home.png"><br> le bouton "retour" pour revenir à la Page 
                                            des algorithmes, <br><img src="images/Back.png"><br>et le bouton "Hint" pour avoir un guide d'utilisation dynamique,
                                            <br><img src="images/Hint.png"><br>.
                                            Vous pouvez basculer entre tous les autres algorithmes à partir de la liste des algorithmes à gauche. <br>
                                            Vous avez 2 méthodes pour remplir le tableau des processus:
                                            <br> 1\ Vous pouvez générer les données aléatoirement, en précisant le nombre des processus ,<br><img src="images/NbProcess.png"><br> et en spécifiant s'il y'a des
                                            interruptions ou non ,<br><img src="images/Interruptions.png"><br> puis cliquez sur "Générer". <br><img src="images/Generer.png"><br>
                                            <br> 2\ Vous pouvez remplir toutes les données de chaque processus[ID, Temps d'arrivée, Durée] par vous-même 
                                            en entrant les options, puis en cliquant sur le bouton "Ajouter", <br><img src="images/AjouterProcess.png"><br>
                                            Vous pouvez aussi modifier ces données en cliquant sur le bouton modifier,<br><img src="images/Modifier.png"><br> 
                                            effectuez vos changement puis cliquez sur modifier pour confirmer vos modifications, <br><img src="images/ModifierOptions.png"><br>   
                                            Pour gérer les interruptions, cliquez sur un processus, <br><img src="images/Interupt.png"><br> Entrez les options de l'interruption et cliquez
                                              sur "+", <br><img src="images/AddInterruptions.png"><br> Et pour les supprimer, cliquez sur "x" .
                                              <br><img src="images/SupprimerProcess.png">
                                        <li class="third_title" id="psr">PSR, PAR</li>
                                        <p>
                                            De même que les algorithmes PAPS, PCA, PLA et PCTR,
                                            remplissez le tableau, et prenez en considération la priorité quand vous ajoutez un processus, 
                                             <br><img src="images/AjouterProcessPSR.png"><br>
                                             et quand vous le modifiez.<br><img src="images/ModifierOptionsPSR.png"><br>
                                        <li class="third_title" id="pard">PARD</li>
                                        <p>
                                            Concernant l'algorithme PARD, Entrez le temps de mise à jour <br><img src="images/TempsMAJ.png"><br> et remplissez le tableau des processus.
                                        <li class="third_title" id="rr">RR</li>             
                                        <p>
                                            Pour l'algorithme de Tourniquet, précisez le quantum, <br><img src="images/quantum.png"><br>
                                            et remplissez le tableau des processus comme déjà montré.
                                    <li class="third_title" id="st">Slack-Time</li>
                                    <p>remplissez le tableau, et prenez en considération le temps mort (deadline) quand vous ajoutez un processus, et quand vous le modifiez.
                                     <br><img src="images/AjouterProcessST.png"><br>
                                                                             
                                    <li class="third_title" id="ml">Multi-Niveaux</li>
                                    <p>
                                        Quand vous cliquez sur l'algorithme Multi-Niveaux/ multi-niveaux avec recyclage, la page de saisie s'ouvre, <img src="images/PageSaisieML.png" height="80%" width="80%"><br> vous trouverez 4 boutons dans l'en tête de la page : le bouton "Home"
                                        "retour","Hint" et "Cours". <br>
                                        <br> 1\ Vous pouvez générer les données aléatoirement, en précisant le nombre des niveaux, <br><img src="images/NbLevels.png"><br> puis cliquez sur processus,
                                        <br><img src="images/ProcessusinML.png"><br>
                                        Cliquez sur “+” pour ajouter un niveau, et sur “-” pour le supprimer.
                                        Puis cliquez sur processus,
                                        pour passer à la page de saisie des processus, <br><img src="images/PageSaisieML2.png" height="80%" width="80%"><br>
                                        Et remplissez le tableau des processus selon les algorithmes choisis comme déjà montré.
                                        <br> 2\ Pour la saisie manuelle, saisissez [niveau, Algorithme, option[dépend de l'algorithme] ] et cliquez sur Ajouter.
                                        <img src="images/AjouterNiveau.png"><br>
                                        Puis cliquez sur Processus <br><img src="images/ProcessusinML.png"><br>
                                        Puis remplissez toutes les données de chaque processus manuellement selon les algorithmes choisis comme déjà montré.
                                    </p>
                                    </ol>
                                    <br>
                                    <li class="second titles" id="simuler">La page de simulation</li>
                                    <li class="third titles" id="processus">Le processus</li>
                                    <p>Dans notre simulation, nous avons représenter le processus par un carré noir, <br><img src="images/process.png" ><br> on trouve à l'intérieur de ce carré 3 nombres :
                                        <br> Celui du centre : représente l'"ID" du processus, càd son identité.
                                        <br> Celui à droite : représente le temps restant à la fin d'exécution du processus.
                                        <br> Et celui à gauche : représente la priorité du processus, elle est définie pour les algorithmes (PAR, PAR, et PARD), et initialisée à 0 pour tous les autres algorithmes. 
                                    </p><br>
                                    
                                    <li class="third titles" id="simuler2">La page de simulation</li>
                                    <img src="images/SimulationPage.png" height="80%" width="80%">
                                    <p>Pour lancer la simulation visuelle de l'algorithme choisi, cliquez sur le bouton "Start", <br><img src="images/Start.png"><br>
                                        Vous pouvez aussi faire pause à la simulation en cliquant sur le bouton "Pause", <br><img src="images/Pause.png"><br> ou refaire la simulation en cliquant 
                                        sur le bouton "repeat". <br><img src="images/Replay.png"><br>
                                        <br> Vous pouvez revenir à tous moments à la page des algorithmes en cliquant sur le bouton "Retour", <br><img src="images/Back.png"><br>
                                        ou revenir à la page d'accueil en cliquant sur le bouton "Home". <br><img src="images/Home.png"><br>
                                        Pour contrôler la vitesse de la simulation, faites défiler la barre de vitesse. <br><img src="images/Vitesse.png"><br>
                                        La simulation commence en fonction du temps qui s'incrémente,les processus se déplacent entre la liste des 
                                        processus prêts, la liste des processus bloqués, et le processeur selon leurs états. <br><img src="images/Simulation.png"><br>
                                        <br> vous trouvez un diagramme de Gantt pour l'évolution des états des processus : dans chaque unité temps, vous trouvez les états de tous les processus : le vert pour l'état actif
                                        , l'orange pour l'état prêt et le rouge pour l'état bloqué.Faites défiler la barre à droite du diagramme pour voir les états de tous 
                                        les processus, et la barre en bas pour changer le temps. <br><img src="images/Gantt.png"><br> Et vous trouvez la transition des états des 
                                        différents processus dans le box "Transition des états". <br><img src="images/Transitions.png"><br>
                                        <br> Pour afficher les résultats de l'algorithme, cliquez sur le bouton "Résultats".<br><img src="images/Results.png"><br>
                                        Le tableau des résultats s'affiche, vous trouvez le temps d'attente, le temps de service, le temps de réponse, et le temps de fin pour chaque processus,
                                        et les temps moyens au-dessous du tableau. <br><img src="images/TableauResultats.png" height="90%" width="90%"><br>
                                        Puis, cliquez sur "terminer" pour quitter le tableau des résultats. <br><img src="images/Terminer.png"><br>
                                    </p>
                                    
                                </ol>
                                <br>
                                <li class="first_titles" id="comparaison">La comparaison</li>
                                <p>Pour faire la comparaison, cliquez sur le bouton Comparer dans la page d'accueil, <br><img src="images/ComparerBtn.png"><br>
                                La page de comparaison apparaîtra, <br><img src="images/PageSaisieComparaison.png" height="80%" width="80%"><br> séléctionnez 2 ou 3 algorithmes d'ordonnancement 
                                que vous voulez comparer en cliquant sur les noms des algorithmes <br><img src="images/SelectionsAlgos.png" height="80%" width="80%"><br>
                                puis remplissez le tableau des processus par vous-même ou bien aléatoirement, et enfin cliquez sur comparer.
                                <br><img src="images/ComparerBtn.png"><br> 
                                Vous aurez la page des résultats : <br><img src="images/PageComparaison.png" height="80%" width="80%"><br>
                                Faites glisser le slider pour voir les résultats de tous les critères [Temps d'attentes, Temps de service, Temps de fin,
                                Usage de la CPU, Nombre des processus en famine]
                                vous trouvez en vert le meilleur résultat, en orange le résultat moyen, et en rouge le mauvais résultat. 
                                <br><img src="images/TempsAtt.png"><br>
                                Cliquez sur le bouton suivant <br><img src="images/Next.png"><br> pour passer à la représentation graphique des résultats.
                                Vous trouverez le "Spider Chart" qui résume la comparaison entre tous les algorithmes selon les critères. 
                                <br><img src="images/SpiderChart.png" height="80%" width="80%"><br>
                                </p>    
                        </ol>
                        <li class="first_titles" id="explication">Fonctionnement des algorithmes</li>
                            <ul>
                                <li class="second titles" id="algo">Algorithme avec réquisition ou sans réquisition ?</li>
                                <p>L'ordonnanceur du CPU permet de décider à quel processus (dans la file d'attente
                                    des processus prêts) attribuer le contrôle du CPU. Les stratégies d'ordonnancement
                                    peuvent être regrouper en deux catégories : sans réquisition du CPU (stratégie non
                                    préemptive) ou avec réquisition du CPU (stratégie préemptive). 
                                    <ol>
                                        <li>Algorithme sans réquisiton :</li>
                                        <p> Dans cette catégorie, un processus conserve le contrôle du CPU jusqu'à ce qu'il se
                                            bloque ou qu'il se termine. Cette approche correspond aux besoins des travaux par
                                            lots (systèmes batch). I</p>
                                        </ol>
                                        <li>Algorithme avec réquisition : </li>
                                        <p>Dans cette catégorie, l'ordonnanceur peut retirer le CPU à un processus avant que
                                            ce dernier ne se bloque ou se termine afin de l'attribuer à un autre processus. A
                                            chaque {quantum} (unité de temps) l'ordonnanceur choisi dans la liste des
                                            processus prêts un processus à qui le CPU sera alloué. Cette approche correspond
                                            aux systèmes interactifs.</p>
                                </p>
                            </ul>
                                    <ol>
                                        <li class="second titles" id="algos">Les algorithmes d'ordonnancement</li>
                                        <ol>
                                            <li class="third_title" id="paps2">PAPS</li>
                                            C’est un algorithme sans réquisition qui consiste à allouer le processeur au premier processus de la liste des processus prêts.
                                            <br> Le processeur ne peut être retiré au processus que s’il le libère volontairement. <br>
                                            
                                            <li class="third_title" id="pca2">PCA</li>
                                            C'est un algorithme sans réquisition.
                                            Le processeur est alloué au travail le plus court (temps demandé).
                                            <br> la priorité d’un processus est inversement proportionnelle au temps processeur demandé. 
                                            <br> PCA est un cas particulier des algorithmes avec priorité.
                                            <br> Priorité=(1/Temps processeur estimé).
                                            
                                            <li class="third_title" id="pla2">PLA</li>
                                            C'est un algorithme sans réquisition.
                                            Le processeur est alloué au travail le plus long (temps demandé). 
                                            <br> la priorité d’un processus est proportionnelle au temps processeur demandé. 
                                            <br> PLA est un cas particulier des algorithmes avec priorité.
                                            <br> Priorité=(1/Temps processeur estimé).
                                            
                                            <li class="third_title" id="pctr2">PCTR</li>
                                            C'est un algorithme sans réquisition. Le processeur est alloué au plus court temps restant. 
                                            <li class="third_title" id="psr2">PSR</li>
                                            C'est un algorithme sans réquisition.
                                            La priorité : Valeur numérique associée à un processus et permettant de le classer selon son importance dans le système.
                                            La priorité statique: attribuée au processus à sa création et reste jusqu’à la fin de l’exécution du processus. 
                                            <br>L'ordonnanceur choisit le processus le plus prioritaire de la liste 
                                            des "processus prêts".
                                            , un processus conserve le contrôle du CPU jusqu'à ce qu'il se
                                            bloque ou qu'il se termine.
                                            <li class="third_title" id="par2">PAR</li> 
                                            De même que l'algorithme avec PSR, mais c'est un algorithme avec réquisition.
                                            C'est à dire, à tout moment t, si un processus plus prioritaire arrive à la liste des processus prêts,
                                            le processus actif (moins prioritaire) se désactive, il rentre à la liste des processus prêts, et le processus le plus prioritaire s'exécute.
                                            <li class="third_title" id="pard2">PARD</li>
                                            C'est un algorithme avec réquisition.
                                            Priorité dynamique: à la création d’un processus , on lui attribut une priorité initiale ensuite cette priorité peut évoluer, par exemple:
                                            <br> • En fonction du temps d’exécution;
                                            <br> • En fonction du nombre d’E/S;
                                            <br> • En fonction du nombre de ressources consommées;
                                            <br> • …
                                            <br> L’évolution de la priorité peut être dans les deux sens : positif ou négatif. 
                                            <br>L'ordonnanceur choisit le processus le plus prioritaire de la ou les file(s) 
                                            des "processus prêts".
                                            <li class="third_title" id="rr2">RR</li>
                                            Cet algorithme ,avec réquisition, est très utilisé dans les systèmes en temps partagé et les systèmes multiprogrammés.
                                            Le processeur est alloué aux processus par tranche de temps appelée ‘quantum de temps’
                                            Le processeur est alloué au premier processus de la file des 'processus prêts' pendant un quantum de temps.
                                            Si le processus n'a pas terminé son exécution, il est recyclé dans la file des 'processus prêts‘.
                                            Le processeur est alloué à un autre processus :
                                            <ul>
                                                <li>A la fin du quantum de temps ➔ interruption horloge.</li>
                                                <li>Si le processus actif se bloque ➔ attente de ressource physique ou logique.</li>
                                                <li>Fin d’exécution du processus(fin normale ou erreur ).</li>
                                            </ul>
                                            Les performances de cet algorithme dépendent du quantum de temps(Q):
                                            <ul>
                                                <li>Si Q est très grand (tend vers l'infini) ➔ équivalent à FIFO.</li>
                                                <li>Si Q est très petit (tend vers 0) ➔ trop de commutations ➔ mauvaise utilisation du processeur.</li>
                                            </ul>
                                            
                                            <li class="third_title">Slack-Time</li>
                                            C'est un algorithme avec réquisition aussi, on représente ici la notion du temps mort.
                                            est un algorithme de planification. Il attribue la priorité en fonction du temps morts d'un processus. 
                                            Le temps mort est le temps restant après un travail si le travail a été démarré maintenant. Cet algorithme est également
                                            connu sous le nom de le moins de laxisme d'abord. Son utilisation la plus courante est dans systèmes embarqués,
                                            en particulier ceux avec plusieurs processeurs. Il impose la simple contrainte que chaque processus sur chaque processeur
                                            disponible possède le même temps d'exécution, et que les processus individuels ne avoir une affinité avec un certain processeur.
                                            C'est ce qui lui confère une adéquation aux systèmes embarqués.
                                            <br> La formule du temps mort : temps mort = (durée) - (temps réel depuis le début du cycle) - (temps restant).
                                            <li class="third_title" id="ml2">ML</li>
                                            L'algorithme des files multi-niveaux est un algorithme avec réquisition.
                                            D'abord, On définit des classes de processus.
                                            Puis, on associe à chaque classe :
                                            <br> • Une priorité (par rapport aux autres classes)
                                            <br> • Définir un algorithme d’ordonnancement
                                            <br> • Le processeur est alloué aux processus de la classe la plus prioritaire.
                                            <br> • On ne change de classe que si la classe la plus prioritaire est vide.
                                            <br> Un processus ne peut pas changer de classe.
                                            
                                            <li class="third_title" id="mlr2">MLR</li>
                                            L'algorithme des files multi-niveaux avec recyclage est un algorithme avec réquisition.
                                            On dispose de n files de 'processus à l’état prêt'.
                                            <br> A chaque file fi est associé un quantum de temps qi dont la valeur croit avec le rang de la file.
                                            <br>Les nouveaux processus sont rangés dans la file f0.
                                            <br>Lorsqu’un processus de la file fi a épuisé son quantum de temps 
                                            sans avoir terminé son exécution, il rentre dans la file fi+1.
                                            <br>Un processus de la file fi n’est servi que si toutes les files de rang 
                                            inférieur à i sont vides.
                                            <br>Cet algorithme favorise les processus courts.
                                        </ol>
                                    </ol>
                    </div>
                </section>
            </main>
        </div>
    </body>
</html>